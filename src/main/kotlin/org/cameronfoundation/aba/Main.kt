package org.cameronfoundation.aba

import com.opencsv.CSVReader
import java.io.File
import java.io.InputStreamReader
import java.time.LocalDate
import kotlin.system.exitProcess

/**
 * Reads in a Transfers CSV file
 * Generates an ABA file for uploading to the bank
 */
fun main(args: Array<String>) {
    val map: Map<String, List<String>> = processArgs(args)

    val csvFiles: List<String>? = map["-csv"]
    if (csvFiles == null || csvFiles.isEmpty()) {
        println("Specify -csv filename.csv")
        exitProcess(0)
    }

    var outFile: File? = null
    val outFileName: List<String>? = map["-out"]
    if (outFileName != null) {
        if (outFileName.size == 1) {
            outFile = File(outFileName[0])
        } else {
            println("Can only specify one output file")
            exitProcess(0)
        }
    }

    //todo Switch between generating CBA file and sending email notifications

    //Configure the generator for Cameron Foundation
    val generator = Generator(
        bsb = "063-142",
        accountNumber = "10419362",
        bankName = "CBA",
        userName = "The Cameron Family Foundat",
        defaultRemitter = "CameronFoundation",

        //See https://www.commbank.com.au/business/pds/003-279-importing-a-de-file.pdf
        //301500 is fixed for CBA Commbiz
        directEntryUserId = "301500",
        description = "Donations"
    )
    generator.includeAccountNumberInDescriptiveRecord = false
    generator.processingDate = LocalDate.now()

    //Read CSV file and generate the transactions.
    // Columns in CSV should match CSVColumn enum - including matching enum ordering
    //The CSV file should have generated by saving the Transfers sheet of our donations
    //spreadsheet as a CSV file.
    val reader = CSVReader(InputStreamReader(File(csvFiles[0]).inputStream()))
    val transactions: ArrayList<Transaction> = ArrayList()
    var tokens: Array<String>?
    while (reader.readNext().also { tokens = it } != null) {
        if (!ignoreLine(tokens)) {
            val amountInCents = tokens!![CSVColumn.AMOUNT.ordinal].toInt() * 100
            val transactionCode =
                if (amountInCents < 0) TransactionCode.EXTERNALLY_INITIATED_DEBIT
                else TransactionCode.EXTERNALLY_INITIATED_CREDIT

            val txn = Transaction(
                amount = kotlin.math.abs(amountInCents),
                accountName = tokens!![CSVColumn.ACCOUNT_NAME.ordinal],
                bsb = tokens!![CSVColumn.BSB.ordinal],
                accountNumber = tokens!![CSVColumn.ACCOUNT_NUMBER.ordinal],
                reference = tokens!![CSVColumn.REFERENCE.ordinal],
                indicator = "N",
                transactionCode = transactionCode.code
            )
            transactions.add(txn)
        }
    }

    //Now generate the ABA file from the transactions
    val abaString = generator.generate(transactions)

    if (outFile == null) {
        println(abaString)
    } else {
        outFile.writeText(abaString)
    }
}

fun ignoreLine(tokens: Array<String>?): Boolean {
    if (tokens == null) {
        return true
    }

    val ignore =
        //Status is not X - ie ready to transfer
        tokens[CSVColumn.STATUS.ordinal] != "X"
        //Amount is 0
        ||tokens[CSVColumn.AMOUNT.ordinal].isBlank() || tokens[CSVColumn.AMOUNT.ordinal].toInt() == 0
        //BSB column is blank or is "BSB"
        || tokens[CSVColumn.BSB.ordinal].isBlank() || tokens[CSVColumn.BSB.ordinal] == "BSB"


    return ignore
}

fun processArgs(args: Array<String>): Map<String, List<String>> {
    //See https://stackoverflow.com/questions/53946908/functional-style-main-function-argument-parsing-for-kotlin
    val map = args.fold(Pair(emptyMap<String, List<String>>(), "")) {
            (map, lastKey): Pair<Map<String, List<String>>, String>, elem: String ->
        if (elem.startsWith("-"))
            Pair(map + (elem to emptyList()), elem)
        else
            Pair(map + (lastKey to map.getOrDefault(lastKey, emptyList()) + elem), lastKey)
    }.first
    return map
}
